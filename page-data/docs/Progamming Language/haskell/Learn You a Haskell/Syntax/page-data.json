{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/docs/Progamming Language/haskell/Learn You a Haskell/Syntax","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"unequal = \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/=\")), mdx(\"p\", null, \"var declaration is simply function declaration with no parameter\"), mdx(\"p\", null, \"2 types of function call:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"prefix\", mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-haskell\"\n  }, \"add 1 2\\n\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"infix - can only be called if it has 2 parameter. requires backtick.\", mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-hs\"\n  }, \"1 `add` 2\\n\")))), mdx(\"p\", null, \"if always requires an else as it's 1 statement\"), mdx(\"p\", null, \"function name needs to start with lowercase letters\"), mdx(\"p\", null, \"string is a list of char\"), mdx(\"p\", null, \"char is wrapped with single quote while string use double quotes\"), mdx(\"p\", null, \"extending list uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"++\"), \", this will result in going thru every element in first list to append to the end of new list\"), mdx(\"p\", null, \"appending to head uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":\"), \", e.g.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-hs\"\n  }, \"'a':\\\"HELLO\\\" -> \\\"aHello\\\"\\n\")), mdx(\"p\", null, \"literal can be thought of as syntactic sugar to prepending list multiple times\"), mdx(\"p\", null, \"extracting an index uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"!!\"), \", e.g.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-hs\"\n  }, \"\\\"HELLO\\\" !! 2 -> 'E'\\n\")), mdx(\"p\", null, \"list are comparable with (in)equality operator. (in)equality check is done in lexicographical order.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"head\"), \" takes the head of a list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tail\"), \" takes the head off and return the list without head\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"last\"), \" takes the last element\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"init\"), \" takes everything but the last element\\nthe above list operation throw error on empty list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"length\"), \" returns the length\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"null\"), \" checks for empty list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"reverse\"), \" reverses list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"take\"), \" takes x element from front of list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"drop\"), \" drops x element from front of list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"maximum\"), \" takes maximum if list are ordered e.g.\", mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"maximum \\\"HELLZO\\\" -> 'Z'\\n\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"minimum\"), \" takes minimum\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sum\"), \" sums list of number\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"product\"), \" multiples all element in list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"elem\"), \" checks if x is in list. usually used as infix\", mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"4 \\\\`elem\\\\` \\\\[3,4,5,6\\\\]\\nTrue\\n\")))), mdx(\"p\", null, \"range are useful way to declare a range of value\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-hs\"\n  }, \"[1..10] -> [1,2,3,4,5,6,7,8,9,10]\\n[2,4..20] -> [2,4,6,8,10,12,14,16,18,20]\\n[10,9..1] -> [10,9,8,7,6,5,4,3,2,1]\\n['A'..'Z'] -> \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\"\\n['A'..'z'] ->\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\\\\\]^_`abcdefghijklmnopqrstuvwxyz\\\"\\n['A','C'..'Z'] -> \\\"ACEGIKMOQSUWY\\\"\\n[1,2..] -> infinite list\\n\")), mdx(\"p\", null, \"float is not very accurate in list so be careful (avoid)\"), mdx(\"p\", null, \"its possible to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"take\"), \" x value from infinite list e.g.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-hs\"\n  }, \"take 5 [2,4..] -> [2,4,6,8,10]\\n\")), mdx(\"p\", null, \"helpful function that returns infinite list:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cycle\"), \" repeats a list to infinity\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"repeat\"), \" repeats an element to infinity\")), mdx(\"p\", null, \"list comprehension takes the form of\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-hs\"\n  }, \"[`expression` | `var` <- `input list`, `filter`]\\n\")), mdx(\"p\", null, \"expression is only applied if filter is true for that element. using two input expression will result in multiplication of length.\"), mdx(\"p\", null, \"tuple is a more rigid list. uses normal parentheses.\"), mdx(\"p\", null, \"tuple can have different type as its element and tuple of different length is considered different types.\"), mdx(\"p\", null, \"a list of list can have list of different length but a list of tuple must all have the same length tuple.\"), mdx(\"p\", null, \"2 useful function for tuple of length 2 (or so called pair):\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"fst\"), \" takes first element\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"snd\"), \" takes second element\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"zip\"), \" combines 2 list (can be diff type) into a list of tuple. it takes the length of the shorter list.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[]},"fields":{"slug":"/docs/Progamming Language/haskell/Learn You a Haskell/Syntax","title":"Syntax"}}},"pageContext":{"id":"0a8b72a1-8966-575c-8fdf-a8ef9c0da9cf"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}