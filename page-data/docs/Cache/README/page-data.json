{"componentChunkName":"component---node-modules-gatsby-theme-kb-src-templates-topic-js","path":"/docs/Cache/README","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#cache\"\n  }, \"Cache\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#behaviour\"\n  }, \"Behaviour\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#caching-pattern\"\n  }, \"Caching Pattern\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#read-through\"\n  }, \"Read Through\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#write-through\"\n  }, \"Write Through\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#write-behind\"\n  }, \"Write Behind\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#write-invalidate\"\n  }, \"Write Invalidate\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#cache-warming\"\n  }, \"Cache Warming\")))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#specific-tools\"\n  }, \"Specific Tools\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#redis\"\n  }, \"Redis\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#cross-tool-logic\"\n  }, \"Cross tool logic\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#binlog---cache\"\n  }, \"Binlog - Cache\"))))))), mdx(\"hr\", null), mdx(\"h1\", null, \"Cache\"), mdx(\"h2\", null, \"Behaviour\"), mdx(\"h3\", null, \"Caching Pattern\"), mdx(\"h4\", null, \"Read Through\"), mdx(\"p\", null, \"Read cache, when not found, check database, write result back to cache. Might have issues with load on cold cache.\"), mdx(\"h4\", null, \"Write Through\"), mdx(\"p\", null, \"Synchronously write to database then cache. (safe because DB first)\"), mdx(\"h4\", null, \"Write Behind\"), mdx(\"p\", null, \"Write to cache then asynchronously write to db. Faster and can batch write but has a chance of losing write to db. Possible race condition issue with handling multiple asynchronous write too.\"), mdx(\"h4\", null, \"Write Invalidate\"), mdx(\"p\", null, \"Write to db then invalidate cache. this results in cache always miss next time.\"), mdx(\"h4\", null, \"Cache Warming\"), mdx(\"p\", null, \"Prefill (warming up) cache (keys) in preparation for high load. can be used on high demand key or regularly updating low demand key.\"), mdx(\"h2\", null, \"Specific Tools\"), mdx(\"h3\", null, \"Redis\"), mdx(\"h2\", null, \"Cross tool logic\"), mdx(\"h4\", null, \"Binlog - Cache\"), mdx(\"p\", null, \"It's possible to listen to DB binlog as an event stream which can trigger cache invalidation/write on certain data. this can be wasteful if you only care about certain data out of the binlog but if you are already listening to the binlog, this can be a useful way.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","private":false},"outboundReferences":[],"inboundReferences":[]},"fields":{"slug":"/docs/Cache/README","title":"Cache"}}},"pageContext":{"id":"dd3d1032-2dbb-58ef-8cb9-ab64bf735cbf"}},"staticQueryHashes":["2221750479","2380733210","2768355698","63159454","847517413"]}